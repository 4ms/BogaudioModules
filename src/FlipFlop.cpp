
#include "FlipFlop.hpp"

void FlipFlop::reset() {
	_flipped1 = false;
	_flipped2 = false;
	_trigger1.reset();
	_resetTrigger1.reset();
	_trigger2.reset();
	_resetTrigger2.reset();
}

void FlipFlop::processChannel(const ProcessArgs& args, int _c) {
	channelStep(
		inputs[IN1_INPUT],
		inputs[RESET1_INPUT],
		outputs[A1_OUTPUT],
		outputs[B1_OUTPUT],
		_trigger1,
		_resetTrigger1,
		_flipped1
	);
	channelStep(
		inputs[IN2_INPUT],
		inputs[RESET2_INPUT],
		outputs[A2_OUTPUT],
		outputs[B2_OUTPUT],
		_trigger2,
		_resetTrigger2,
		_flipped2
	);
}

void FlipFlop::channelStep(
	Input& triggerInput,
	Input& resetInput,
	Output& aOutput,
	Output& bOutput,
	PositiveZeroCrossing& trigger,
	Trigger& resetTrigger,
	bool& flipped
) {
	bool triggered = trigger.next(triggerInput.getVoltage());
	resetTrigger.process(resetInput.getVoltage());
	if (resetTrigger.isHigh()) {
		flipped = false;
	}
	else if (triggered) {
		flipped = !flipped;
	}

	if (flipped) {
		aOutput.setVoltage(0.0f);
		bOutput.setVoltage(5.0f);
	}
	else {
		aOutput.setVoltage(5.0f);
		bOutput.setVoltage(0.0f);
	}
}

struct FlipFlopWidget : ModuleWidget {
	static constexpr int hp = 3;

	FlipFlopWidget(FlipFlop* module) {
		setModule(module);
		box.size = Vec(RACK_GRID_WIDTH * hp, RACK_GRID_HEIGHT);

		{
			SvgPanel *panel = new SvgPanel();
			panel->box.size = box.size;
			panel->setBackground(APP->window->loadSvg(asset::plugin(pluginInstance, "res/FlipFlop.svg")));
			addChild(panel);
		}

		addChild(createWidget<ScrewSilver>(Vec(0, 0)));
		addChild(createWidget<ScrewSilver>(Vec(box.size.x - 15, 365)));

		// generated by svg_widgets.rb
		auto in1InputPosition = Vec(10.5, 21.0);
		auto reset1InputPosition = Vec(10.5, 56.0);
		auto in2InputPosition = Vec(10.5, 172.0);
		auto reset2InputPosition = Vec(10.5, 207.0);

		auto a1OutputPosition = Vec(10.5, 94.0);
		auto b1OutputPosition = Vec(10.5, 129.0);
		auto a2OutputPosition = Vec(10.5, 245.0);
		auto b2OutputPosition = Vec(10.5, 280.0);
		// end generated by svg_widgets.rb

		addInput(createInput<Port24>(in1InputPosition, module, FlipFlop::IN1_INPUT));
		addInput(createInput<Port24>(reset1InputPosition, module, FlipFlop::RESET1_INPUT));
		addInput(createInput<Port24>(in2InputPosition, module, FlipFlop::IN2_INPUT));
		addInput(createInput<Port24>(reset2InputPosition, module, FlipFlop::RESET2_INPUT));

		addOutput(createOutput<Port24>(a1OutputPosition, module, FlipFlop::A1_OUTPUT));
		addOutput(createOutput<Port24>(b1OutputPosition, module, FlipFlop::B1_OUTPUT));
		addOutput(createOutput<Port24>(a2OutputPosition, module, FlipFlop::A2_OUTPUT));
		addOutput(createOutput<Port24>(b2OutputPosition, module, FlipFlop::B2_OUTPUT));
	}
};

Model* modelFlipFlop = bogaudio::createModel<FlipFlop, FlipFlopWidget>("Bogaudio-FlipFlop", "FlipFlop",  "dual stateful logic", "Logic", "Dual");
