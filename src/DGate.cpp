
#include "DGate.hpp"

void DGate::onReset() {
	_trigger.reset();
	_triggerOuptutPulseGen.process(10.0);
	_stage = STOPPED_STAGE;
	_stageProgress = 0.0;
}

void DGate::process(const ProcessArgs& args) {
	float envelope = 0.0;
	bool complete = false;
	if (
		_trigger.process(params[TRIGGER_PARAM].getValue() + inputs[TRIGGER_INPUT].getVoltage()) ||
		(_firstStep && _triggerOnLoad && _shouldTriggerOnLoad && params[LOOP_PARAM].getValue() <= 0.0)
	) {
		_stage = DELAY_STAGE;
		_stageProgress = 0.0;
	}
	else {
		switch (_stage) {
			case STOPPED_STAGE: {
				break;
			}
			case DELAY_STAGE: {
				if (stepStage(params[DELAY_PARAM])) {
					_stage = GATE_STAGE;
					_stageProgress = 0.0;
				}
				break;
			}
			case GATE_STAGE: {
				if (stepStage(params[GATE_PARAM])) {
					complete = true;
					if (params[LOOP_PARAM].getValue() <= 0.0 || _trigger.isHigh()) {
						_stage = DELAY_STAGE;
						_stageProgress = 0.0;
					}
					else {
						_stage = STOPPED_STAGE;
					}
				}
				else {
					envelope = 1.0;
				}
				break;
			}
		}
	}

	outputs[GATE_OUTPUT].setVoltage(envelope * 10.0);
	if (complete) {
		_triggerOuptutPulseGen.trigger(0.001);
	}
	outputs[END_OUTPUT].setVoltage(_triggerOuptutPulseGen.process(APP->engine->getSampleTime()) ? 5.0 : 0.0);

	lights[DELAY_LIGHT].value = _stage == DELAY_STAGE;
	lights[GATE_LIGHT].value = _stage == GATE_STAGE;

	_firstStep = false;
}

bool DGate::stepStage(Param& knob) {
	float t = knob.value;
	t = pow(t, 2);
	t = fmaxf(t, 0.001);
	t *= 10.0;
	_stageProgress += APP->engine->getSampleTime() / t;
	return _stageProgress > 1.0;
}

struct DGateWidget : ModuleWidget {
	static constexpr int hp = 3;

	DGateWidget(DGate* module) {
		setModule(module);
		box.size = Vec(RACK_GRID_WIDTH * hp, RACK_GRID_HEIGHT);

		{
			SVGPanel *panel = new SVGPanel();
			panel->box.size = box.size;
			panel->setBackground(APP->window->loadSvg(asset::plugin(pluginInstance, "res/DGate.svg")));
			addChild(panel);
		}

		addChild(createWidget<ScrewSilver>(Vec(0, 0)));
		addChild(createWidget<ScrewSilver>(Vec(box.size.x - 15, 365)));

		// generated by svg_widgets.rb
		auto delayParamPosition = Vec(8.0, 33.0);
		auto gateParamPosition = Vec(8.0, 92.0);
		auto loopParamPosition = Vec(15.0, 144.5);
		auto triggerParamPosition = Vec(13.5, 191.0);

		auto triggerInputPosition = Vec(10.5, 213.0);

		auto gateOutputPosition = Vec(10.5, 252.0);
		auto endOutputPosition = Vec(10.5, 287.0);

		auto delayLightPosition = Vec(20.8, 65.0);
		auto gateLightPosition = Vec(20.8, 124.0);
		// end generated by svg_widgets.rb

		addParam(createParam<Knob29>(delayParamPosition, module, DGate::DELAY_PARAM));
		addParam(createParam<Knob29>(gateParamPosition, module, DGate::GATE_PARAM));
		addParam(createParam<SliderSwitch2State14>(loopParamPosition, module, DGate::LOOP_PARAM));
		addParam(createParam<Button18>(triggerParamPosition, module, DGate::TRIGGER_PARAM));

		addInput(createInput<Port24>(triggerInputPosition, module, DGate::TRIGGER_INPUT));

		addOutput(createOutput<Port24>(gateOutputPosition, module, DGate::GATE_OUTPUT));
		addOutput(createOutput<Port24>(endOutputPosition, module, DGate::END_OUTPUT));

		addChild(createLight<TinyLight<GreenLight>>(delayLightPosition, module, DGate::DELAY_LIGHT));
		addChild(createLight<TinyLight<GreenLight>>(gateLightPosition, module, DGate::GATE_LIGHT));
	}

	void appendContextMenu(Menu* menu) override {
	  DGate* dgate = dynamic_cast<DGate*>(module);
		assert(dgate);
		menu->addChild(new MenuLabel());
		menu->addChild(new TriggerOnLoadMenuItem(dgate, "Resume loop on load"));
	}
};

Model* modelDGate = bogaudio::createModel<DGate, DGateWidget>("Bogaudio-DGate", "DGate",  "trigger-to-gate with delay");
